{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This Primer aims to help you understand foundations of geospatial analysis and visualization with Google Earth Engine. It is intended for people who are unfamiliar with geospatial or Earth Engine concepts and methods. This is a work in progress. I hope to have the first draft complete by January 2022. For questions or comments, please contact: Jeff Howarth Associate Professor Geography Department Middlebury College, Vermont, USA email: jhowarth@middlebury.edu twitter: @jeffgeographer","title":"Introduction"},{"location":"01/rasterFoundations/","text":"Introduction This chapter introduces foundations of raster datasets and how to visualize them as map layers in Earth Engine. We will use the Earth Engine Code Editor to work with a global dataset of Nighttime Lights and make a new map layer (shown below) that visualizes how nighttime lights changed between 1993, 2003, and 2013. By the end of the chapter, you should understand how to: construct an image collection from an address in the Earth Engine data catalog filter collection by attribute and time visualize images as map layers reduce an image collection into an image threshold image by criteria reuse workflows with functions compare images with logical expressions visualize bands with RGB composites Construct image collection To get started, use the Code Editor to construct an image collection from the Earth Engine Data Catalog . Copy or type the following code into the Code Editor and then run the script. var lights = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ); print ( \"Lights at night dataset\" , lights ); The first line uses Earth Engine's ImageCollection method, where the parameter defines the asset ID of the dataset in the Data Catalog. You can give the result any name you would like. Above, I call it 'lights'. The second line prints two things: a label and the collection's metadata (data about data). Inspect the metadata and note the following: The image collection consists of a set of images (listed as features of the image collection). The image collection and each image have properties (some of which are human readable and some of which seem intended for a computer). Each image consists of a set of bands (the names of which are a little cryptic, but you can follow the provider_url in the image collection properties to find descriptions of them). If this architecture is new to you, the next section reviews how the raster data model works as a general template for storing spatial information. Raster data model The raster data model represents spatial information as an array of values. The position of a value in the array represents location. Each value represents an attribute of the location. The illustration above shows two versions of a raster for a small portion of the nighttimes lights dataset near Belem, Brasil. The left-side shows how the computer encodes the data and the right-side shows a scheme that is a bit more readable. On the left, the array holds 8 bit unsigned integers. This data type uses eight binary numbers to represent integers between 0 and 255. The scheme on the right shows a grid with four columns and five rows. Each cell in the grid is called a pixel (short for \"picture element\"). As you can see, the raster template stores one value for each location. How then does the nighttime lights dataset store multiple values for each location? For example, it contains both the brightness of nighttime lights and the cloudiness of the nighttime sky for every location. Similarly, how does the dataset store values for more than one observation in time, making it possible to investigate change over time? The solution is two-part: use more than one raster and use a hierarchy to organize them. This is where bands and image collections come in. Earth Engine's raster system insert image The figure above illustrates EE's raster system that we glimpsed earlier in the nighttime lights metadata: The image collection consists of a set of images. Each image in the image collection represents a different time observation. Each band in an image represents a different category of attributes. Filter image collection Now that we have explored this basic architecture, we can recognize that our image collection suffers from a bit of excess. We constructed \"lights\" from the entire dataset in the EE catalog, but we only need a subset for our analysis. So our next task is to shorten the stack of rasters. To do this, we will filter the image collection in two ways: by time by attribute This snippet filters by time : var lights2003 = lights . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )); print ( 'Lights 2003' , lights2003 ); It calls an image collection's filter method and then uses the filter's calendarRange method, where the parameters define the range's start, end, and calendar field. In this example, we use the 'year' calendar field because each image in the nighttime lights collection represents an average for the calendar year so there is no reason to define a filter smaller than this. The second line prints a label and metadata to the Console. Inspect the metadata and note that now your image collection contains two images and both are for the year 2003. This snippet filters by attribute : var lights2003Select = lights03 . select ( 'stable_lights' ); print ( 'Nighttime lights 2003 Select' , lights2003Select ); It calls an image collection's select method, where the parameter states the band name. Inspect the metadata and note that this image collection only contains one band. This code did the job, but it could be more concise. We could replicate all the code that we have written thus far with the following: var lights03 = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ) . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )) . select ( 'stable_lights' ); print ( 'Lights 2003: concise method' , lights03 ); If you inspect the metadata, you should see this image collection is identical to the collection we made earlier. To help understand why, let's review how raster workflows work. Raster workflow elements Take a raster, do something to it, get a result. This triad is the basic element of a workflow. Input \u2192 method \u2192 output In javascript, you declare ends before means and methods are properties of the input class. The syntax is this: var output = input . method (); Most raster workflows consist of a chain or sequence of these actions. For example, our workflow thus far consists of a sequence of three. insert image When we first scripted the workflow, we declared a variable for each intermediate result and then used this variable as an input in the next step. In our more concise script, we didn't bother declaring intermediate outputs and simply wrote out the chain of action. They both work and the more verbose approach allowed us to inspect each intermediate output, which can be helpful when learning how methods work and for trouble-shooting if something goes wrong. As you become familiar with EE methods, however, you may find the concise style more efficient. Working with the Map UI So far, we have only investigated the image collection by printing the metadata to the Console. In this section, we will use the Code Editor's Map User Interface (UI) to visualize the collection's spatial information. To warm up, we can change the basemap that the Code Editor automatically displays on the Map. By default, the Map shows the familiar Google road map. You can change this manually with the buttons in the upper right corner of the map window, but it will revert to road map whenever you re-run your code. Alternatively, you can script a particular basemap to display on the Map. This snippet will display the satellite basemap with labels whenever we re-run the script: Map . setOptions ( 'HYBRID' ); By default, the Map centers on a point in eastern Kansas in the American Midwest at a zoom level of 4. Often, you will be interested in a scale and extent that differs from this. You can change the map extent manually by using the pan and zoom buttons in the upper left of the map window, or alternatively you can specify the map center and zoom level in your script. For example, the line below centers the Map near the Korean Peninsula with a zoom level that shows eastern China and southern Japan. Map . setCenter ( 125 , 35 , 6 ); Cartographic model If you are not certain what the three parameters in the setCenter method reference, then take a moment to try querying a location on the Map with this routine: Click on the \"Inspector\" tab (top-right) \u2192 cursor becomes a crosshair Click anywhere on the map \u2192 prints lon, lat, zoom, and scale to inspector panel If you are used to thinking about latitude and longitude in that order, you should note that the order shown in the inspector panel is opposite of this, following the \"x,y\" convention of coordinates. As a geographic coordinate, longitude is plotted along the x-axis and latitude on the y-axis, which is counter-intuitive for many people, because we tend to equate longitude with vertical lines and latitude with horizontal lines. Also note that positive longitudes are east of Greenwich, England and negative are west. Positive latitudes are north of the equator and negatives are south. insert image Zoom level describes map scale. Small zoom levels show small scale maps. When you increase the zoom level, you increase the map scale. Similarly, when you click on the + button (upper left corner of map window), you increase the zoom level. This has the illusion of bringing the map closer to you, or of zooming in. It may not seem intuitive to think that large scale maps show smaller extents than small scale maps. This confusion stems from associating scale with area rather than detail. Large scale maps show more detail than small scale maps. In the Inspector panel, the scale value reports the approximate distance on the ground (in meters) at the equator that is represented by a single pixel. Increasing the zoom level decreases this distance and this increases detail. insert image Visualize data with color The Map UI enables you to visualize raster values with color schemes. As a first step, we will define visualization parameters : var lightsPalette = [ 'black' , '#000b4a' , '#5a2c49' , '#94574e' , '#c9875e' , '#f4bf87' , 'white' ]; var lightsViz = { min : 0 , max : 63 , palette : lightsPalette }; print ( 'palette and viz' , lightsPalette , lightsViz ); Inspect the result in the Console. The palette variable is a list of colors. The visualization parameters variable is an object with three properties: min and max define the data range we want to display with colors, while palette references the list of colors to display. The palette in this example illustrates two different methods to specify colors. For many standard colors, we can declare a color by name, as we did for 'black' and 'white'. Alternatively, we can construct colors from hexadecimal codes . These codes are a clever way of defining colors as combinations of red, green, and blue, which we will discuss in more detail a little later in this chapter. Also note that we set the min and max values based on the range of values that populate the raster. For some bands, the min and max will be defined as properties of the image collection. Alternatively, you can also look in EE's Data Catalog for metadata about the collection. It is often listed under the Bands tab . Stretch enhancement Visualization parameters help resolve a common mismatch between the range of values that a raster can store (defined by the data type) and the range of values that populate the raster. Often, the raster uses much less than the data type provides and this affects our ability to see differences in our data with color. Stretch enhancement matches the range of display colors to the range of populated data values in order to improve visual contrast. The frequency distribution above illustrates this for our simple 20 pixel example introduced previously. It shows the number of pixels (y-axis) that populate the raster for each value provided by the data type (x-axis). The eight bit unsigned integer data type can represent all integers between 0 and 255, but our raster contains values over a much smaller range (0 - 48). Now consider that the pixel depth will also control the number of colors available to visualize the raster values. In the illustration, the palette lists six discrete colors. These colors seed a color ramp that then represents all the potential values provided by the pixel depth. The first color represents 0, the last color represents 255. The other colors are distributed evenly across the middle and transitional colors are made up to fill in the gaps. The color ramp appears continuous, but it really just represents 256 steps between black and white that pass through the other five colors at equal intervals. The raw display simply uses the color ramp to represent all the potential values in the raster as defined by the data type. The result has poor contrast, because we are only using a small part of our color ramp to display our raster values. The stretched display solves this by stretching our data range (defined by the minimum and maximum values, or 0 and 48 in this example) over the entire color ramp. This improves contrast dramatically, because we are now using our full range of color to represent our full range of populated values. Add map layer After we have defined how we want colors to represent data values, we can add a raster to the Map UI as a layer with this snippet: var layerParams = { eeObject : lights03 , visParams : lightsViz , name : 'Stable lights stretched' , shown : 1 , opacity : 1 }; Map . addLayer ( layerParams ); This uses the Map's addLayer method after first constructing a JavaScript object to hold the method's five parameters. When you run the code, the Map UI displays the lit1993 raster with our visualization parameters. When you click the layers button on the top right of the map window, you will see the layer name ('Stable lights stretched') and a check mark signifying that the layer is being shown. We made the layer opaque, so we can not see the base map underneath it. As you become familiar with the Map's addLayer method, you may find it convenient to nest parameters within methods rather than declaring them as separate variables. For example, this snippet is functionally equivalent to the previous one: Map . addLayer ( lit1993 , lightsViz , 'Stable lights stretched: nested params' , 1 , 1 ); Similarly, you will likely encounter code that nests the visualization parameters like this: Map . addLayer ( lit1993 , { min : 0 , max : 63 , palette : lightsPalette }, 'Stable lights stretched: nested viz params' , 1 , 1 ); Note that the curly brackets define the visualization parameters as an object within the method. Reusability strategies Reduce an image collections Remember that our image collection contained two images for the year 2003. How then were we able to add the image collection to the Map as a single layer? ```","title":"Raster Foundations"},{"location":"01/rasterFoundations/#introduction","text":"This chapter introduces foundations of raster datasets and how to visualize them as map layers in Earth Engine. We will use the Earth Engine Code Editor to work with a global dataset of Nighttime Lights and make a new map layer (shown below) that visualizes how nighttime lights changed between 1993, 2003, and 2013. By the end of the chapter, you should understand how to: construct an image collection from an address in the Earth Engine data catalog filter collection by attribute and time visualize images as map layers reduce an image collection into an image threshold image by criteria reuse workflows with functions compare images with logical expressions visualize bands with RGB composites","title":"Introduction"},{"location":"01/rasterFoundations/#construct-image-collection","text":"To get started, use the Code Editor to construct an image collection from the Earth Engine Data Catalog . Copy or type the following code into the Code Editor and then run the script. var lights = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ); print ( \"Lights at night dataset\" , lights ); The first line uses Earth Engine's ImageCollection method, where the parameter defines the asset ID of the dataset in the Data Catalog. You can give the result any name you would like. Above, I call it 'lights'. The second line prints two things: a label and the collection's metadata (data about data). Inspect the metadata and note the following: The image collection consists of a set of images (listed as features of the image collection). The image collection and each image have properties (some of which are human readable and some of which seem intended for a computer). Each image consists of a set of bands (the names of which are a little cryptic, but you can follow the provider_url in the image collection properties to find descriptions of them). If this architecture is new to you, the next section reviews how the raster data model works as a general template for storing spatial information.","title":"Construct image collection"},{"location":"01/rasterFoundations/#raster-data-model","text":"The raster data model represents spatial information as an array of values. The position of a value in the array represents location. Each value represents an attribute of the location. The illustration above shows two versions of a raster for a small portion of the nighttimes lights dataset near Belem, Brasil. The left-side shows how the computer encodes the data and the right-side shows a scheme that is a bit more readable. On the left, the array holds 8 bit unsigned integers. This data type uses eight binary numbers to represent integers between 0 and 255. The scheme on the right shows a grid with four columns and five rows. Each cell in the grid is called a pixel (short for \"picture element\"). As you can see, the raster template stores one value for each location. How then does the nighttime lights dataset store multiple values for each location? For example, it contains both the brightness of nighttime lights and the cloudiness of the nighttime sky for every location. Similarly, how does the dataset store values for more than one observation in time, making it possible to investigate change over time? The solution is two-part: use more than one raster and use a hierarchy to organize them. This is where bands and image collections come in.","title":"Raster data model"},{"location":"01/rasterFoundations/#earth-engines-raster-system","text":"insert image The figure above illustrates EE's raster system that we glimpsed earlier in the nighttime lights metadata: The image collection consists of a set of images. Each image in the image collection represents a different time observation. Each band in an image represents a different category of attributes.","title":"Earth Engine's raster system"},{"location":"01/rasterFoundations/#filter-image-collection","text":"Now that we have explored this basic architecture, we can recognize that our image collection suffers from a bit of excess. We constructed \"lights\" from the entire dataset in the EE catalog, but we only need a subset for our analysis. So our next task is to shorten the stack of rasters. To do this, we will filter the image collection in two ways: by time by attribute This snippet filters by time : var lights2003 = lights . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )); print ( 'Lights 2003' , lights2003 ); It calls an image collection's filter method and then uses the filter's calendarRange method, where the parameters define the range's start, end, and calendar field. In this example, we use the 'year' calendar field because each image in the nighttime lights collection represents an average for the calendar year so there is no reason to define a filter smaller than this. The second line prints a label and metadata to the Console. Inspect the metadata and note that now your image collection contains two images and both are for the year 2003. This snippet filters by attribute : var lights2003Select = lights03 . select ( 'stable_lights' ); print ( 'Nighttime lights 2003 Select' , lights2003Select ); It calls an image collection's select method, where the parameter states the band name. Inspect the metadata and note that this image collection only contains one band. This code did the job, but it could be more concise. We could replicate all the code that we have written thus far with the following: var lights03 = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ) . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )) . select ( 'stable_lights' ); print ( 'Lights 2003: concise method' , lights03 ); If you inspect the metadata, you should see this image collection is identical to the collection we made earlier. To help understand why, let's review how raster workflows work.","title":"Filter image collection"},{"location":"01/rasterFoundations/#raster-workflow-elements","text":"Take a raster, do something to it, get a result. This triad is the basic element of a workflow. Input \u2192 method \u2192 output In javascript, you declare ends before means and methods are properties of the input class. The syntax is this: var output = input . method (); Most raster workflows consist of a chain or sequence of these actions. For example, our workflow thus far consists of a sequence of three. insert image When we first scripted the workflow, we declared a variable for each intermediate result and then used this variable as an input in the next step. In our more concise script, we didn't bother declaring intermediate outputs and simply wrote out the chain of action. They both work and the more verbose approach allowed us to inspect each intermediate output, which can be helpful when learning how methods work and for trouble-shooting if something goes wrong. As you become familiar with EE methods, however, you may find the concise style more efficient.","title":"Raster workflow elements"},{"location":"01/rasterFoundations/#working-with-the-map-ui","text":"So far, we have only investigated the image collection by printing the metadata to the Console. In this section, we will use the Code Editor's Map User Interface (UI) to visualize the collection's spatial information. To warm up, we can change the basemap that the Code Editor automatically displays on the Map. By default, the Map shows the familiar Google road map. You can change this manually with the buttons in the upper right corner of the map window, but it will revert to road map whenever you re-run your code. Alternatively, you can script a particular basemap to display on the Map. This snippet will display the satellite basemap with labels whenever we re-run the script: Map . setOptions ( 'HYBRID' ); By default, the Map centers on a point in eastern Kansas in the American Midwest at a zoom level of 4. Often, you will be interested in a scale and extent that differs from this. You can change the map extent manually by using the pan and zoom buttons in the upper left of the map window, or alternatively you can specify the map center and zoom level in your script. For example, the line below centers the Map near the Korean Peninsula with a zoom level that shows eastern China and southern Japan. Map . setCenter ( 125 , 35 , 6 );","title":"Working with the Map UI"},{"location":"01/rasterFoundations/#cartographic-model","text":"If you are not certain what the three parameters in the setCenter method reference, then take a moment to try querying a location on the Map with this routine: Click on the \"Inspector\" tab (top-right) \u2192 cursor becomes a crosshair Click anywhere on the map \u2192 prints lon, lat, zoom, and scale to inspector panel If you are used to thinking about latitude and longitude in that order, you should note that the order shown in the inspector panel is opposite of this, following the \"x,y\" convention of coordinates. As a geographic coordinate, longitude is plotted along the x-axis and latitude on the y-axis, which is counter-intuitive for many people, because we tend to equate longitude with vertical lines and latitude with horizontal lines. Also note that positive longitudes are east of Greenwich, England and negative are west. Positive latitudes are north of the equator and negatives are south. insert image Zoom level describes map scale. Small zoom levels show small scale maps. When you increase the zoom level, you increase the map scale. Similarly, when you click on the + button (upper left corner of map window), you increase the zoom level. This has the illusion of bringing the map closer to you, or of zooming in. It may not seem intuitive to think that large scale maps show smaller extents than small scale maps. This confusion stems from associating scale with area rather than detail. Large scale maps show more detail than small scale maps. In the Inspector panel, the scale value reports the approximate distance on the ground (in meters) at the equator that is represented by a single pixel. Increasing the zoom level decreases this distance and this increases detail. insert image","title":"Cartographic model"},{"location":"01/rasterFoundations/#visualize-data-with-color","text":"The Map UI enables you to visualize raster values with color schemes. As a first step, we will define visualization parameters : var lightsPalette = [ 'black' , '#000b4a' , '#5a2c49' , '#94574e' , '#c9875e' , '#f4bf87' , 'white' ]; var lightsViz = { min : 0 , max : 63 , palette : lightsPalette }; print ( 'palette and viz' , lightsPalette , lightsViz ); Inspect the result in the Console. The palette variable is a list of colors. The visualization parameters variable is an object with three properties: min and max define the data range we want to display with colors, while palette references the list of colors to display. The palette in this example illustrates two different methods to specify colors. For many standard colors, we can declare a color by name, as we did for 'black' and 'white'. Alternatively, we can construct colors from hexadecimal codes . These codes are a clever way of defining colors as combinations of red, green, and blue, which we will discuss in more detail a little later in this chapter. Also note that we set the min and max values based on the range of values that populate the raster. For some bands, the min and max will be defined as properties of the image collection. Alternatively, you can also look in EE's Data Catalog for metadata about the collection. It is often listed under the Bands tab .","title":"Visualize data with color"},{"location":"01/rasterFoundations/#stretch-enhancement","text":"Visualization parameters help resolve a common mismatch between the range of values that a raster can store (defined by the data type) and the range of values that populate the raster. Often, the raster uses much less than the data type provides and this affects our ability to see differences in our data with color. Stretch enhancement matches the range of display colors to the range of populated data values in order to improve visual contrast. The frequency distribution above illustrates this for our simple 20 pixel example introduced previously. It shows the number of pixels (y-axis) that populate the raster for each value provided by the data type (x-axis). The eight bit unsigned integer data type can represent all integers between 0 and 255, but our raster contains values over a much smaller range (0 - 48). Now consider that the pixel depth will also control the number of colors available to visualize the raster values. In the illustration, the palette lists six discrete colors. These colors seed a color ramp that then represents all the potential values provided by the pixel depth. The first color represents 0, the last color represents 255. The other colors are distributed evenly across the middle and transitional colors are made up to fill in the gaps. The color ramp appears continuous, but it really just represents 256 steps between black and white that pass through the other five colors at equal intervals. The raw display simply uses the color ramp to represent all the potential values in the raster as defined by the data type. The result has poor contrast, because we are only using a small part of our color ramp to display our raster values. The stretched display solves this by stretching our data range (defined by the minimum and maximum values, or 0 and 48 in this example) over the entire color ramp. This improves contrast dramatically, because we are now using our full range of color to represent our full range of populated values.","title":"Stretch enhancement"},{"location":"01/rasterFoundations/#add-map-layer","text":"After we have defined how we want colors to represent data values, we can add a raster to the Map UI as a layer with this snippet: var layerParams = { eeObject : lights03 , visParams : lightsViz , name : 'Stable lights stretched' , shown : 1 , opacity : 1 }; Map . addLayer ( layerParams ); This uses the Map's addLayer method after first constructing a JavaScript object to hold the method's five parameters. When you run the code, the Map UI displays the lit1993 raster with our visualization parameters. When you click the layers button on the top right of the map window, you will see the layer name ('Stable lights stretched') and a check mark signifying that the layer is being shown. We made the layer opaque, so we can not see the base map underneath it. As you become familiar with the Map's addLayer method, you may find it convenient to nest parameters within methods rather than declaring them as separate variables. For example, this snippet is functionally equivalent to the previous one: Map . addLayer ( lit1993 , lightsViz , 'Stable lights stretched: nested params' , 1 , 1 ); Similarly, you will likely encounter code that nests the visualization parameters like this: Map . addLayer ( lit1993 , { min : 0 , max : 63 , palette : lightsPalette }, 'Stable lights stretched: nested viz params' , 1 , 1 ); Note that the curly brackets define the visualization parameters as an object within the method.","title":"Add map layer"},{"location":"01/rasterFoundations/#reusability-strategies","text":"","title":"Reusability strategies"},{"location":"01/rasterFoundations/#reduce-an-image-collections","text":"Remember that our image collection contained two images for the year 2003. How then were we able to add the image collection to the Map as a single layer? ```","title":"Reduce an image collections"}]}